# C/C++_programmin

## 目录
[返回主目录](https://github.com/NightBonsai/C-C-_programming/blob/main/README.md)

## 内存&指针

### 1.所有指针定义时先给指针赋初值（避免野指针）*：

    NULL（定义在“stdio.h”中）	    0x00000000
	  无类型指针void *p:	    什么类型的地址都能接收
	
### 2.指针变量所占内存：
与基础数据类型无关，只与操作系统有关

### 3.指针可指向字符串常量

### 4.C++内存布局：

    代码区（code）：存储程序的可执行代码，通常是只读的
    数据区（data）：存储全局变量和静态变量，包括初始化的和未初始化的变量
		    堆区（heap）：程序员手动分配释放（malloc、free），动态分配的内存
		    栈区（stack）：编译器自动分配释放，存放函数的参数值，局部变量的值
    
    其他区域：包括一些特殊的内存区域，如环境变量区、命令行参数区等

### 5.分配动态内存:
记得最后释放申请的动态内存<dr>
(int*)强制类型转化<dr>
可分配连续动态内存<dr>

    int *x;
    x=(int*)malloc(sizeof(int));
    if(x==NULL)
    {
        printf("申请动态内存失败\n");
	exit(0);
    }
    ...
    free(x);

### 6.new和malloc的区别：
		
    new/delete为关键词；
    malloc/free为库函数

    new在调用时，先为对象分配内存，再调用对象构造函数；
    malloc不会；

    new调用时不需要明确给出分配的内存空间大小；
    malloc需要；

    new分配内存空间成功返回对象指针；
    malloc分配内存空间成功返回无符号void*类型指针
		
### 7.sizeof和strlen的区别：
		
    sizeof是运算符；
    strlen是库函数；
		
    sizeof用来获取某个数据类型所占用空间的字节数；
    strlen用来计算指定的字符串 s 的长度，不包括结束字符"\0"

    sizeof()在编译时计算好了；
    strlen()在运行时计算

    sizeof()的参数类型多样化（数组，指针，对象，函数都可以）；
    strlen()的参数必须是字符型指针（传入数组时自动退化为指针）

### 8.内存泄露：
- 1.数组越界访问or容器越界访问
- 2.局部变量销毁导致函数返回失效；**今后多次经过同一函数，该函数内尽量避免使用局部变量，将变量声明为类属性**

### 9.指针和引用区别
		
    指针：保存另一个变量内存地址的变量
    引用：另一个变量的别名，一旦被初始化就不能被改变
          一个具有自动间接性的常量指针，相当于编译器帮助实现了自动间接性取值
          编译器帮助加上了 *，引用内部实现为指针

### 10.引用&：
- 只能引用数组元素，不能引用数组
- 不能定义引用的引用，所以当函数的参数为引用时，引用不能作实参
